% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/deconvolve.R
\name{deconvolve}
\alias{deconvolve}
\title{Deconvolve a known linear filter}
\usage{
deconvolve(
  s,
  f,
  type = c("wl", "dls", "noreg"),
  alpha = 0.1,
  metric = c("median", "max", "percentile")
)
}
\arguments{
\item{s}{real-valued univariate or multivariate (as matrix columns) timeseries.}

\item{f}{real-valued filter to deconvolve.}

\item{type}{one of water-level ("wl", default), damped "least squqres" ("dls") or no regularization ("noreg").
See detail for more information}

\item{alpha}{multiplier of the max or median value of the denominator for the corresponding \code{metric},
If \code{metric} is "percentile", this specifies the percentile value of the denominator to use in regularization.}

\item{metric}{one of "max" (default), "median" or "percentile."  Together with \code{alpha} this determines
the regularization of the deconvolution.}
}
\value{
Deconvolved timeseries
}
\description{
Deconvolve a known linear filter from sampled univariate or multivariate timeseries using standard spectral
division with or without some regularization.
}
\details{
If the convolved filter has spectral zeros
(or near zeros), any noise in that band will be greatly exaggerated by deconvolution. To control this,
it is common to regularize the denominator during spectral division (deconvolution in the frequency domain).
Two methods are provided. (1) water-level ("wl") doesn't allow the value of the denominator to drop below the scaled metric.
Visually, the denominator plotted against frequency is filled with water up to the scaled metric, thus
filling in "holes."  (2) damped "least-squares" ("dls") simply adds the scaled metric to the
denominator at all frequencies.  Visually, this shifts the baseline of the denominator up.  While this
reduces the noise-amplification of zeros and near-zeros, it biases results at all frequencies.
Type "noreg" applies no regularization and will produce useless results for noisy inputs.

The scaled metric is one of:
alpha * max( D ),
alpha * median( D ), or
quantile( D, alpha )
where D is the denominator (function of frequency).

Deconvolution is circular.  Long filters will cycle around.
Padding \code{s} prior to deconvolution is often desirable.
}
\examples{
# Create spike sequence
r <- runif( 1024, min = 0, max = 1 )
c <- which( r > 0.95 )
r <- rep( 0, 1024 )
r[c] <- 5 * rnorm( length( c ) )

# Create a wavelet
t <- seq( 0, 1023, 1 )
w <- 10 * dnorm( t, sd = 10 ) * sin( 2.0 * pi * t / 20 )

# Convolve spikes with wavelet and add white noise.
z <- convolve( r, w, conj = FALSE, type = "circular" ) + rnorm( 1024, sd = 0.1 )

# Deconvolve
rd <- deconvolve( z, w, type = "wl", metric = "max", alpha = 0.005 )
plotl( r, main = "Water Level" )
lines( rd, col = "red" )
rd <- deconvolve( z, w, type = "dls", metric = "max", alpha = 0.005 )
plotl( r, main = "Damped LS" )
lines( rd, col = "red" )
}
